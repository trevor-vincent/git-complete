* git-complete.el

Yet another completion engine powered by =git grep=

=git grep= を使った補完エンジン

** Description

=git-complete= provides an interactive command which, when invoked,
scans the current git project with =git grep= and suggests what you
may want to insert.

[[screencast.gif]]

=git-complete= CAN:

- complete *not just a symbol but the whole idiom* if appropreate,
  unlike other completion engines (rather like snippet engines)

- be used as an "omni (smart) completion" engine, i.e. =git-complete=
  tries to suggest expressions you may want to insert next, *even when
  you don't remember it*, by grepping your project (class methods
  after a class name, typical argument for a function, for examples)

- be used with *no per-language configurations or dictionaries*,
  unlike snippet engines or omni-completion engines

=git-complete= CAN'T:

- complete expressions which has not been used in the git project yet

- start completion automatically, since it's a bit laggy to git grep
  over the git repo (especially for the first invokation in the
  project)

- be 100% accurate, since =git-complete= has no knowledge about the
  language you are coding in

EXTRA FEATURES:

- "autopair"
  - =git-complete= (optionally) tries to keep the parenthesis balance
    by inserting or deleting some parens if appropreate

- DWIM newline insertion
  - =git-complete= tries to insert newline after completion if you may
    want so

*** See also:

The =git grep= idea is taken from =auto-programming.el= by hitode909.

https://github.com/hitode909/emacs-auto-programming

- Atom version: =atom-auto-programming= by the author of
  =auto-programming.el=
  - https://github.com/hitode909/atom-auto-programming

- Vim version: =vim-auto-programming= by haya14busa
  - https://github.com/haya14busa/vim-auto-programming

** Quickstart
*** Installation

#+begin_src emacs-lisp
  (require 'git-complete)
#+end_src

and (optionally) bind some keys.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-c") 'git-complete)
#+end_src

*** Examples

(Consider "|" as the cursor in following examples)

Open a file under a git repo, and =M-x git-complete=

- after a part of a package name (frequently used in your project)

  #+begin_src perl
    SHA|
  #+end_src

  completes the import statement.

  #+begin_src perl
    use Digest::SHA;
    |
  #+end_src

- after a constructor

  #+begin_src javascript
    var foo = moment().|
  #+end_src

  suggests method names frequently used in your project.

  #+begin_src javascript
    var foo = moment().format(|
  #+end_src

  and =M-x git-complete= (again) suggests typical arguments to the
  method frequently used in your project.

  #+begin_src javascript
    var foo = moment().format("YYYY-MM-DD HH:mm:ss"|
  #+end_src

- after a complete line

  #+begin_src perl
    use strict;
    |
  #+end_src

  suggests the next line which usually follows "use strict;" in your
  project.

  #+begin_src perl
    use strict;
    use warnings;
    |
  #+end_src

** Customizations

- =git-complete-enable-autopair= : either git-complete should keep the
  parenthesis balance during completion

- =git-complete-ignore-case= : either to use =--ignore-case= option or
  not when git grepping

See "How it works" section for details:

- =git-complete-threshold=
- =git-complete-whole-line-completion-threshold=
- =git-complete-next-line-completion-threshold=
- =git-complete-repeat-completion=

** How it works

There are two completion methods:

- current-line completion
- next-line completion

and current-line completion has two submethods:

- omni-completion
- next-line completion

They work as follows:

- current line has no characters before the cursor ?
  - yes -> do "next-line completion"
  - no -> do "line completion"
    - no line-completion candidates found ?
      - -> fall back to "omni completion"
    - some candidates satisfy "whole-line completion threshold" ?
      - -> try "whole-line completion"

Each completion methods works as follows.

*** Line completion

before:

: React|            * consider | as the cursor

after:

: import React from 'react';
: |

1. Collect lines containing "React" in your git repo, by =git grep=
   -ing with "React"

   : > git grep -F -h "React"
   : import React from 'react';
   :     var class = React.createClass({
   :     var class = React.createClass({
   : import React from 'react';
   :     var class = React.createClass({
   : import React from 'react';
   : import ReactDOM from 'react-dom';
   :     var class = React.createClass({
   :         ReactDOM.render(<MyComponent />);
   : import React from 'react';
   :     var class = React.createClass({
   : import ReactDOM from 'react-dom';
   :     ReactDOM.render(<AnotherComponent />);
   : ...

2. Find the longest (described below) common substrings of the lines,
   which frequently appears (threshold can be configured with
   =git-complete-threshold=)

   - "longest" :: if "format()" is a completion candidate, for
                  example, its prefixes like "fo" and "forma" are not
                  suggested

   : |                                   | frequency |
   : +-----------------------------------+-----------+
   : | var class = React.createClass({   |       60% |
   : | import React from 'react';        |       30% |
   : | import ReactDOM from 'react-dom'; |        5% |
   : | ReactDOM.render(                  |        5% |
   : | ...                               |       ... |

   (note that arguments to =ReactDOM.render= are dropped since they
   does not appears "frequently")

   - If no such suggestions are found here, try omni-completion

3. For each suggestions,

   - If it is an exact-match (that is, is not trimmed unlike
     =ReactDOM.render=) and satisfies
     =git-complete-whole-line-completion-threshold= (in addition to
     =git-complete-threshold=), then mark it as a "whole-line"
     completion candidate

   - Otherwise, trim the candidate from the beginning, to the query
     string ("React" in this example)

   : |                                   | frequency | whole-line ? |
   : +-----------------------------------+-----------+--------------|
   : | var class = React.createClass({   |       60% |          yes |
   : | import React from 'react';        |       30% |          yes |
   : | DOM from 'react-dom';             |        5% |           no |
   : | DOM.render(                       |        5% |           no |
   : | ...                               |       ... |          ... |

4. Query user to select a suggestion

5. If selected suggestion

   - is a "whole-line" completion, then delete all characters before
     the cursor in the current line, then insert the completion

     before:

     : React|

     after:

     : import React from 'react';
     : |

   - is not a "whole-line" completion, simply insert the completion

     before:

     : React|

     after:

     : ReactDOM.render(|

**** Omni completion

before:

: var foo = bar(MyClass.|

after:

: var foo = bar(MyClass.my_awesome_method|

- if line-completion (i.e. =git grep= with "var foo = bar(MyClass.")
  failed, fall back to omni completion

1. Let the initial query be "var foo = var(MyClass.".

   - If the query is empty, or all characters in the query are
     whitespaces, fail (call =git-complete-fallback-function= if set).

2. =git grep= with the query.

3. Trim the lines found in 2., from the beginning to the query string.

4. Find the longest (described below) common substrings of the lines,
   which frequently appears (accoding to =git-complete-threshold=)

   - If no such substrings are fonud, shorten the query by one word
     (i.e. new query will be "foo = bar(MyClass.", then
     "bar(MyClass.", finally "MyClass.". This behavior can be
     configured with =git-complete-omni-completion-type=), and back
     to the step 2.

5. Query user to select a suggestion, and insert it

*** Next-line completion

before:

: use strict;
: |

after:

: use strict;
: use warnings;
: |

1. Collect lines next to "use strict;" in your git repo, by git
   grepping with "use strict;"

   : > git grep -F -h -A1 "use strict;"
   : use strict;
   : sub foo {
   : --
   : use strict;
   : use warnings;
   : --
   : use strict;
   : use warnings;
   : --
   : use strict;
   : sub bar {
   : --
   : use strict;
   : use utf8;
   : --
   : ...

2. Find the "whole-line" matches (see "Line completion" section)
   frequently appears in your repo (threshold can be configured with
   =git-complete-next-line-completion-threshold=)

   : |                       | frequency |
   : +-----------------------+-----------|
   : | use warnings;         |       80% |
   : | use utf8;             |       20% |
   : | ...                   |       ... |

   - If no such matches are found, fail (call
     =git-complete-fallback-function= if set).

3. Query user to select a suggestion, and insert it

** "autopair" feature

When =git-grep-enable-autopair= is non-nil, the parenthesis balance is
always kept during completion.

*** Whole-line (Next-line) completion

- Open paren

  If the completion being inserted has more *open* parens than close
  parens:

  : query:
  : validate|            * consider | as the cursor

  : completion:
  : my %params = Params::Validate::validate(@_, {

  then close parens (and an empty line) are inserted automatically.

  : result:
  : my %params = Params::Validate::validate(@_, {
  :     |
  : })

- Close paren

  If the completion being inserted has more *close* parens than open
  parens:

  : query:
  : my_awesome_function(
  :   |
  : )

  : completion:
  : an_awesome_argument)

  then the close parens in the next line is mereged into the
  replacement :

  : result:
  : my_awesome_function(
  :   an_awesome_argument)
  : |

  If no such close paren exist in the next line, then open parens are
  inserted at the beginning of the replacement, instead.

  : query:
  : my_awesome_function(
  :   |
  :   another_awesome_argument
  : );

  : result:
  : my_awesome_function(
  :   (an_awesome_argument)
  :   |
  :   foo
  : );

  (I'm not sure this behavior is very useful ... but just to keep the
  balance. maybe improved in the future versions ... ?)

*** Otherwise

- Open paren

  If the completion being inserted has more *open* parens than close
  parens:

  : query:
  : var formatted = moment.format|

  : completion:
  : ("YYYY-MM-DD HH:mm:ss",

  then close parens are inserted automatically (without an empty line,
  unlike whole-line completion).

  : result:
  : var formatted = moment.format("YYYY-MM-DD HH:mm:ss",|)

- Close paren

  If the completion being inserted has more *close* parens than open
  parens:

  : query:
  : var foo = my_awesome_function(|)

  : completion:
  : an_awesome_argument), bra, bra, bra

  then the close paren and characters outside the paren (=bra, bra,
  bra=) are dropped from the completion:

  : result:
  : var foo = my_awesome_function(an_awesome_argument|)
